package com.digitalcrafts.media{		import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.events.TimerEvent;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.utils.Dictionary;	import flash.utils.Timer;		public class AudioManager	{				public var audioData:XML;				private var mediaFilesLoaded:uint;		private var mediaFilesTotal:uint;				private var _enabled:Boolean = true;		private var loadComplete_callback:Function = function(){};		private var soundComplete_callback:Function = function(){};		private var chainComplete_callback:Function = function(){};				private var delayTimer:Timer;				public var debug:Boolean = true;				public var allMedia:Dictionary;		public var currentMedia:Dictionary;				public var musicSolo:Boolean = true;		public var currentMusic:Dictionary;				public var currentVoice:Dictionary;				public var currentAmbience:Dictionary;				private var voiceChain:Array;		private var voiceChainVol:Number = 1;		private var voiceChainComplete:Function;				// CONSTANTS		private const DELAY_LENGTH:Number = 500;				public function AudioManager()		{			delayTimer = new Timer(DELAY_LENGTH, 1);		}				public function load_audio_data($data_url:String, $loadComplete_callback:Function=null):void		{			loadAudioData($data_url, $loadComplete_callback);		}		public function loadAudioData($data_url:String, $loadComplete_callback:Function=null):void		{			// tell the AudioManager the location of the XML file that describes the audio data			// feed it a callback to run when all sound files are loaded						allMedia = new Dictionary();			currentMedia = new Dictionary();			currentMusic = new Dictionary();			currentVoice = new Dictionary();			currentAmbience = new Dictionary();						// fetch the XML			var loader:URLLoader = new URLLoader();			loader.addEventListener(Event.COMPLETE, load_audioData_complete);			loader.load(new URLRequest($data_url));						// if a complete event was sent then set it			if($loadComplete_callback != null)			{				loadComplete_callback = $loadComplete_callback;			}		}		private function load_audioData_complete(e:Event):void		{			// adopt the data from the loaded XML			audioData = new XML(e.target.data);						// immediately try to load all sound files			loadSounds();		}				public function loadSounds():void{			// loads every sound file in the XML data			var thisSound:Sound;			var URLString:String;			var mediaDataList:XMLList = audioData.sound;			var media:SoundMedia;						// total helps us track when ALL sound files have finished loading			mediaFilesTotal = mediaDataList.length();			mediaFilesLoaded = 0;									for(var i:uint=0;i<mediaDataList.length();i++){				URLString = String(audioData.folder_prefix)+String(mediaDataList[i].@file);				if(debug) trace("URLString: "+URLString);								thisSound = new Sound();				thisSound.addEventListener(Event.COMPLETE, loadedSoundFile);				thisSound.addEventListener(IOErrorEvent.IO_ERROR, loadedSoundFileError);				// load the sound				thisSound.load(new URLRequest(URLString));								// store the new SoundMedia object				media = new SoundMedia(mediaDataList[i].@name, thisSound);				//mediaList[i] = media;				allMedia[String(mediaDataList[i].@name)] = media;			}		}		private function loadedSoundFile(e:Event):void{			mediaFilesLoaded++;			if(debug) trace ("AudioManager loaded "+mediaFilesLoaded+" of "+mediaFilesTotal);			if(mediaFilesLoaded == mediaFilesTotal){				// all voice sounds are loaded				loadComplete_callback();			}		}		private function loadedSoundFileError(e:IOErrorEvent):void{			mediaFilesLoaded++;			if(debug) trace("ERROR - "+e.text);		}		public function playVoice($name:String, $vol:Number = 1, $completeFunction:Function=null){			if(debug) trace("playVoice("+$name+")");			if(!_enabled){				return;			}						stopVoice();						var media:SoundMedia = allMedia[$name];			if(media){				currentMedia[$name] = media;				currentVoice[$name] = media;								media.vol = $vol;				media.addEventListener(MediaEvent.MEDIA_COMPLETE, completeSound);				media.play(-1000, 0);								// if a complete event was sent then set it				if($completeFunction!=null){					media.completeFunction = $completeFunction;				}else{					media.completeFunction = function(){};				}			}		}		public function stopVoice():void{			// stop any currently playing voice			for(var i:String in currentVoice){				currentVoice[i].stop();				if(currentMedia.hasOwnProperty(i)){					delete currentMedia[i];				}			}			currentVoice = new Dictionary();		}		public function playVoiceChain($chain:Array, $vol:Number = 1, $completeFunction:Function=null):void{			voiceChain = new Array().concat($chain);			voiceChainVol = $vol;			voiceChainComplete = $completeFunction;			playVoiceChainNext();		}		private function playVoiceChainNext():void{			trace("voiceChain: "+voiceChain);			if(!voiceChain || voiceChain.length == 0){				return;			}else if(voiceChain.length == 1){				playVoice(voiceChain[0], voiceChainVol, voiceChainComplete);			}else{				playVoice(voiceChain[0], voiceChainVol, playVoiceChainNext);			}			voiceChain.splice(0, 1);		}				public function playAmbience($name:String, $vol:Number = 1, $loop:Boolean = true):void{			if(debug) trace("playAmbience("+$name+")");			if(!_enabled || currentAmbience.hasOwnProperty($name)){				return;			}			for(var i:String in currentAmbience){				currentAmbience[i].stop();			}			var media:SoundMedia = allMedia[$name];			if(media){				currentMedia[$name] = media;				currentAmbience[$name] = media;								media.vol = $vol;				//media.play(-1000, $loops).addEventListener(Event.SOUND_COMPLETE, completeSound);				media.addEventListener(MediaEvent.MEDIA_COMPLETE, completeSound);				if($loop){					media.play(-1000, 9999);				}else{					media.play(-1000, 0);				}			}			if(debug) trace("media: "+media);		}		public function stopAmbience():void{			if(debug) trace("stopAmbience()");			// stop any currently playing voice			for(var i:String in currentAmbience){				currentAmbience[i].stop();				if(currentMedia.hasOwnProperty(i)){					delete currentMedia[i];				}			}			currentAmbience = new Dictionary();		}		public function playMusic($name:String, $vol:Number = 1, $completeFunction:Function=null, $loop:Boolean = true):void{			if(debug) trace("playMusic("+$name+")");			if(!_enabled || currentMusic.hasOwnProperty($name)){				if(debug) trace("this music is already playing");				return;			}			if(musicSolo){				stopMusic();			}			var media:SoundMedia = allMedia[$name];			if(media){				currentMedia[$name] = media;				currentMusic[$name] = media;								media.vol = $vol;				//media.play(-1000, $loops).addEventListener(Event.SOUND_COMPLETE, completeSound);				media.addEventListener(MediaEvent.MEDIA_COMPLETE, completeSound);				if($loop){					media.play(-1000, 9999);				}else{					media.play(-1000, 0);				}								// if a complete event was sent then set it				if($completeFunction!=null){					media.completeFunction = $completeFunction;				}else{					media.completeFunction = function(){};				}			}		}		public function stopMusic():void{			if(debug) trace("stopMusic()");			// stop any currently playing voice			for(var i:String in currentMusic){				currentMusic[i].stop();				if(currentMedia.hasOwnProperty(i)){					delete currentMedia[i];				}			}			currentMusic = new Dictionary();		}		// SOUND EFFECTS - each sound effect gets its own sound channel and a new sound effect doesn't stop an old one. SFX doesn't need delay.		public function sfxEvent($name:String, $completeFunction:Function=null, $vol:Number = 1, $loops:uint = 0):void{			playSFX($name, $completeFunction, $vol, $loops);		}		public function playSFX($name:String, $completeFunction:Function=null, $vol:Number = 1, $loops:uint = 0):void{			if(debug) trace("playSFX("+$name+")");			if(!_enabled){				return;			}						var media:SoundMedia = allMedia[$name];			if(debug) trace("media: "+media);			// if media is found			if(media){				currentMedia[$name] = media;								media.vol = $vol;				//media.play(-1000, $loops).addEventListener(Event.SOUND_COMPLETE, completeSound);				media.addEventListener(MediaEvent.MEDIA_COMPLETE, completeSound);				media.play(-1000, $loops);								// if a complete event was sent then set it				if($completeFunction!=null){					media.completeFunction = $completeFunction;				}else{					media.completeFunction = function(){};				}			}		}		public function playIf($name:String, $completeFunction:Function=null, $vol:Number = 1, $loops:uint = 0):void{			var media:SoundMedia = allMedia[$name];			if(media){				if(!media.isPlaying){					playSFX($name, $completeFunction, $vol, $loops);				}else{					if(debug) trace("Can't play that media - it is already playing");				}			}		}		public function stopSound($name:String):void{			if(debug) trace("stopSound() $name: "+$name);			var media:SoundMedia = allMedia[$name];						if(currentMedia.hasOwnProperty($name)){				delete currentMedia[$name];			}			if(currentMusic.hasOwnProperty($name)){				delete currentMusic[$name];			}			if(currentVoice.hasOwnProperty($name)){				delete currentVoice[$name];			}			if(currentAmbience.hasOwnProperty($name)){				delete currentAmbience[$name];			}						if(media){				media.stop();			}		}		public function stopAllSounds():void{			if(debug) trace("stopAllSounds()");			for(var i in currentMedia){				currentMedia[i].stop();			}			currentMedia = new Dictionary();			currentMusic = new Dictionary();			currentVoice = new Dictionary();			currentAmbience = new Dictionary();		}				public function completeSound(e:Event):void{			if(debug) trace("completeSound() "+e.currentTarget);/*			var media:Object = get_media_by_soundChannel(SoundChannel(e.target));			if(media){				media.isPlaying = false;				isPlaying = false;				soundComplete_callback();				for(var i:uint = 0;i<currentMedia.length;i++){					if(currentMedia[i] == media){						if(debug) trace(" removing current media");						currentMedia.splice(i, 1);						break;					}				}			}*/		}		public function enable(b:Boolean):void{			_enabled = b;		}		/*public function get_media_by_name(n:String):Object{			var media:Object = null;			// find the voice event with the matching name			for(var i:uint=0;i<mediaList.length;i++){				if(n == mediaList[i].name){					media = mediaList[i];					break;				}			}			return media;		}		public function get_media_by_soundChannel(sc:SoundChannel):Object{			var media:Object = null;			// find the voice event with the matching name			for(var i:uint=0;i<mediaList.length;i++){				if(sc == mediaList[i].channel){					media = mediaList[i];					break;				}			}			return media;					}		public function get_media_by_sound(snd:Sound):Object{			var media:Object = null;			// find the voice event with the matching name			for(var i:uint=0;i<mediaList.length;i++){				if(snd == mediaList[i].sound){					media = mediaList[i];					break;				}			}			return media;					}*/	}}