package{	import br.com.stimuli.loading.BulkLoader;	import br.com.stimuli.loading.BulkProgressEvent;		import com.digitalcrafts.media.AudioManager;	import com.greensock.TweenLite;	import com.greensock.easing.Back;		import flash.display.AVM1Movie;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.geom.Point;	import flash.media.SoundMixer;	import flash.net.*;	import flash.text.TextField;	import flash.ui.Mouse;	import flash.utils.Timer;		import flashx.textLayout.elements.BreakElement;		public class CorusOPP2012Doc extends MovieClip	{		private const debug:Boolean = true;		private const testingLocally:Boolean = true;		private var bulkLoader:BulkLoader;		private var urlPrefix:String = "";		private var configData:XML;		private var audioData:XML;		private var backgroundSWF:MovieClip;		private var preloadSWF:MovieClip;		private var preload_bar:MovieClip;		private var swfLoadList:XMLList;		private var gameSWF:MovieClip;		private var drillSWF:MovieClip;		private var animations:Object;		private var drillScreen:drill_screen;		private var splashScreen:splash_screen;		private var instructionsScreen:instructions_screen;		private var highScoresScreen:highscores_screen;		private var animationScreen:animation_screen;		private var gameOverScreen:game_over_screen;		private var gameScreen:Sprite;		private var drillResults:Array;		private var drillQuestions:Array;		private var audioManager:AudioManager;		private var my_hitbox:hitbox;		private var animation:MovieClip;				// testing		private var shortcut_clip:MovieClip;				// game vars		private const rank_names:Array = ['MEME', 'SMITH', 'OPERATOR', 'TRINITY', 'MORPHEUS', 'NEO'];		private const powerup_types:Array = ['turbo', 'gum', 'fix'];				private var jiggle_timer:Timer;		private var drill_over_timer:Timer;		private var respawn_timer:Timer;		private var death_timer:Timer;		private var powerup_spawn_timer:Timer;		private var powerup_duration_timer:Timer;				private var level:uint;		private var max_levels:uint;		private var total_score:uint;		private var round_score:uint;		private var _conversion_rate:Number;		private var conversion_bonus:Number;		private var k_speed_x:Number;		private var k_speed_y:Number;		private var k_decay:Number;		private var k_minspeed:Number = -17;		private var k_maxspeed:Number = 17;		private var k_angle:Number;		private var k_dir:String;		private var k_falling:Boolean;		private var speed_modifier:Number;				private var _lives:uint;		private var _hitPoints:Number;		private var maxHitPoints:Number;		private var _progress:Number;		private var barrier_h_list:Array;		private var barrier_v_list:Array;		private var powerup_spawn_list:Array;		private var current_powerups:Array;		private var current_enemies:Array;		private var enemy_speed:Number;		private var chase_distance:Number;		private var stop_distance:Number;		private var convert_distance:Number;		private var meme_damage:Number;		private var converted_memes:uint;		private var total_memes:uint;		private var progress_marker_list:Array;		private var exited:Boolean;		private var meme_points:uint;		private var piece_scale:Number;				// game clips		private var kerblooey:player_clip;		private var gameMap:Sprite;		private var gamePath:MovieClip;		private var hudScreen:game_hud;		private var progress_meter:MovieClip;		private var damage_meter:MovieClip;		private var trackball:MovieClip;		private var gameGrid:MovieClip;		private var gameGlyphs:MovieClip;		private var gameBkgr:MovieClip;				public function CorusOPP2012Doc()		{			super();			trace("CorusOPP2012Doc");			init();		}				private function init():void{			// first load the preloader swf						// adjust the url for live viewing			if(!testingLocally){				urlPrefix = "swf/flashapp/";			}						audioManager = new AudioManager();			my_hitbox = new hitbox();						loadPreloader();		}				private function loadPreloader():void{			// load the initial graphics and data that we need in order to do the actual pre-loading			bulkLoader = new BulkLoader("preloader");			//CALVIN			bulkLoader.add(urlPrefix+"swf3/preload.swf", {'id':"preloadSWF"});			bulkLoader.add(urlPrefix+"swf3/background.swf", {'id':"backgroundSWF"});			bulkLoader.add(urlPrefix+"swf3/xml/configXML.xml", {'id':"configData"});			/*bulkLoader.add(urlPrefix+"preload.swf", {'id':"preloadSWF"});			bulkLoader.add(urlPrefix+"background.swf", {'id':"backgroundSWF"});			bulkLoader.add(urlPrefix+"xml/configXML.xml", {'id':"configData"});*/			//bulkLoader.add(urlPrefix+"xml/audio_data.xml", {'id':"audioData"});			bulkLoader.addEventListener(BulkLoader.COMPLETE, preloadSWFComplete);			bulkLoader.addEventListener(BulkLoader.ERROR, handleLoadError);			bulkLoader.start();		}				private function preloadSWFComplete(e:BulkProgressEvent):void{			// remove listeners			bulkLoader.removeEventListener(BulkLoader.COMPLETE, preloadSWFComplete);			bulkLoader.removeEventListener(BulkLoader.ERROR, handleLoadError);						// recover the background clip			backgroundSWF = (bulkLoader.getContent("backgroundSWF") as MovieClip);						// recover the preload clip			preloadSWF = (bulkLoader.getContent("preloadSWF") as MovieClip);			preload_bar = preloadSWF['bar_mc'];			preload_bar.gotoAndStop(1);						// get the game configuration data			configData = new XML(bulkLoader.getContent("configData"));						// set up the animation pattern in the background clip			doBkgrAnim();						// manage display			addChild(backgroundSWF);			addChild(preloadSWF);						// load the audio			//CALVIN			audioManager.loadAudioData(urlPrefix+"swf3/xml/audio_data.xml", loadContent);			//audioManager.loadAudioData(urlPrefix+"xml/audio_data.xml", loadContent);						// load the next batch of clips			//loadContent();		}				private function doBkgrAnim():void{			//backgroundSWF.bkgr_anim			/*for (i=1;i<=20;i++) {				theGlyphs = this["Glyphs" + i];				theGlyphs._y = _root.randInt(-1000,450);				theGlyphs.moveY = _root.randInt(5,10);				theGlyphs.onEnterFrame = function() {					this._y += this.moveY;					if (this._y > 450) {						this._y = -1000;						this.moveY = _root.randInt(5,10);					}				}			}*/			var glyph:MovieClip;			for (var i:int=1;i<=20;i++) {				glyph = backgroundSWF.bkgr_anim["Glyphs"+i];				glyph.y = randInt(-1000,450);				glyph.moveY = randInt(5,10);				glyph.addEventListener(Event.ENTER_FRAME,					function(e:Event):void{						var mc = (e.currentTarget as MovieClip)						mc.y += mc.moveY;						if(mc.y > 450){							mc.y = -1000;							mc.moveY = randInt(5, 10);						}					}				);			}		}				function randInt(num0:Number,num1:Number) {			if (arguments.length == 1) {				return (Math.round(Math.random() * num0));			} else {				return (Math.round(Math.random() * Math.abs(num0 - num1)) + num0);			}		}				private function loadContent():void{			var node:XML;			var url:String;			var id:String;						// identify the preload items from the XML config data			swfLoadList = configData.preload_items.children();			//trace('swfLoadList: '+swfLoadList);						// load the content files			bulkLoader = new BulkLoader("content");			for(var i:uint = 0;i<swfLoadList.length();i++){				node = new XML(swfLoadList[i]);				url = String(node.attribute("url"));				id = String(node.attribute("id"));				bulkLoader.add(urlPrefix+url, {'id':id, "pausedAtStart":true});			}						bulkLoader.addEventListener(BulkLoader.COMPLETE, contentLoadComplete);			bulkLoader.addEventListener(BulkLoader.PROGRESS, handleProgress);			bulkLoader.addEventListener(BulkLoader.ERROR, handleLoadError);			bulkLoader.start();		}				private function handleProgress(e:BulkProgressEvent):void{			var perc:Number =  Math.floor(e.percentLoaded);			preload_bar.gotoAndStop(perc+1);		}				private function contentLoadComplete(e:BulkProgressEvent):void{			trace("contentLoadComplete");			bulkLoader.removeEventListener(BulkLoader.COMPLETE, contentLoadComplete);			bulkLoader.removeEventListener(BulkLoader.ERROR, handleLoadError);						gameSWF = bulkLoader.getContent("gameplay");			drillSWF = bulkLoader.getContent("drill");						animations = new Object();			animations['intro_anim'] = bulkLoader.getContent("intro_anim");			animations['midgame_anim'] = bulkLoader.getContent("midgame_anim");			animations['endgame_anim'] = bulkLoader.getContent("endgame_anim");			animations['gameover_anim'] = bulkLoader.getContent("gameover_anim");						setup();		}		private function handleLoadError(e:Event):void{			trace("loading error");		}				private function setup():void{			removeChild(preloadSWF);						// absorb important variables from the config data			max_levels = Number(configData.game_vars.max_levels);						// initialize all the screen types			gameInit();			drillInit();			menuInit();			instructionsInit();			highScoresInit();			animationInit();			gameOverInit();						// go to the menu			showMenu();		}				private function drillInit():void{			drillScreen = new drill_screen();			drillScreen.safe_btn.addEventListener(MouseEvent.CLICK, drillSafeClick);			drillScreen.not_safe_btn.addEventListener(MouseEvent.CLICK, drillNotSafeClick);			drillScreen.squares_mc.gotoAndStop(level+1);						var q_node:XML;			drillQuestions = new Array();			var q_obj:Object;			var drillQuestionsXML:XMLList = configData.drill_questions.children();			for(var j:uint = 0;j<drillQuestionsXML.length();j++){				q_node = new XML(drillQuestionsXML[j]);				q_obj = new Object();				q_obj['text'] = String(q_node.attribute("text"));				q_obj['safe'] = String(q_node.attribute("safe"));				drillQuestions.push(q_obj);			}			drillQuestions = shuffle_array(drillQuestions);		}				private function drillSafeClick(e:MouseEvent):void{			evaluate_drill("yes");		}				private function drillNotSafeClick(e:MouseEvent):void{			evaluate_drill("no");		}				private function evaluate_drill(click_result:String):void{			// prevent multiple clicks			drillScreen.mouseEnabled = drillScreen.mouseChildren = false;						var result_clip:MovieClip = drillScreen['result_'+String(level)];			// evaluate			if(drillQuestions[level-1]['safe'] == click_result){				// show question answered correctly				result_clip.gotoAndStop(2);				drillResults.push(true);				// award points				score += conversion_bonus;				//				audioManager.playSFX("right_answer");				my_hitbox.logGameEvent("correct_answer", false);			}else{				// show question answered incorrectly				result_clip.gotoAndStop(3);				drillResults.push(false);				audioManager.playSFX("wrong_answer");				my_hitbox.logGameEvent("incorrect_answer", false);			}			TweenLite.from(result_clip, 0.4, {scaleX:0.20, scaleY:0.20, ease:Back.easeOut});						drill_over_timer.start();		}				private function gameInit():void{			// only run one time when the application first runs			gameScreen = new Sprite();			gameMap = new Sprite();			kerblooey = new player_clip();			hudScreen = new game_hud();						k_maxspeed = Number(configData.game_vars.max_speed);			k_minspeed = 0-k_maxspeed;			k_decay = Number(configData.game_vars.speed_decay);			maxHitPoints = Number(configData.game_vars.hit_points);			enemy_speed = Number(configData.game_vars.enemy_speed);			chase_distance = Number(configData.game_vars.chase_distance);			stop_distance = Number(configData.game_vars.stop_distance);			convert_distance = Number(configData.game_vars.convert_distance);			meme_damage = Number(configData.game_vars.meme_damage);			meme_points = Number(configData.game_vars.meme_points);			piece_scale = Number(configData.game_vars.piece_scale);						// listen for events in the character animation			k_dir = "N";			kerblooey.addEventListener("keyframe", manage_kerblooey_dir);			kerblooey.addEventListener("exit", exitLevel);						// set up the HUD			progress_meter = (hudScreen.progress_mc as MovieClip);			damage_meter = (hudScreen.damage_mc as MovieClip);			progress_meter.gotoAndStop(1);			damage_meter.gotoAndStop(1);			trackball = (hudScreen.trackball_mc as MovieClip);			trackball.addEventListener(MouseEvent.MOUSE_DOWN, track_mouse_start);						// map elements			gameBkgr = new game_screen_bkgr();			gameGlyphs = new game_screen_glyphs();			gameGrid = new game_screen_grid();			gameScreen.addChild(gameBkgr);			gameScreen.addChild(gameGlyphs);			gameScreen.addChild(gameGrid);						jiggle_timer = new Timer(100, 14);			jiggle_timer.addEventListener(TimerEvent.TIMER, jiggle_trackball);						respawn_timer = new Timer(400, 1);			respawn_timer.addEventListener(TimerEvent.TIMER_COMPLETE, respawn_kerblooey);						drill_over_timer = new Timer(2000, 1);			drill_over_timer.addEventListener(TimerEvent.TIMER_COMPLETE, nextLevel);						death_timer = new Timer(900, 1);			death_timer.addEventListener(TimerEvent.TIMER_COMPLETE, player_died);						powerup_spawn_timer = new Timer(10000, 0);			powerup_spawn_timer.addEventListener(TimerEvent.TIMER, spawn_powerup)						powerup_duration_timer = new Timer(10000, 0);			powerup_duration_timer.addEventListener(TimerEvent.TIMER, restore_speed);						kerblooey.gotoAndStop(1);			kerblooey.turn_mc.gotoAndStop(1);						kerblooey.scaleX = kerblooey.scaleY = piece_scale;						gameScreen.addChild(gameMap);			gameScreen.addChild(hudScreen);		}				private function newGame():void{			// refresh all game vars for a new game			score = 0;			round_score = 0;			conversion_rate = 0;						level = Number(configData.game_vars.start_level);			lives = Number(configData.game_vars.lives);			hitPoints = Number(configData.game_vars.hit_points);						drillResults = new Array();			for(var i:uint = 1;i<=5;i++){				drillScreen['result_'+String(i)].gotoAndStop(1);			}						// send the hitbox			my_hitbox.logGameEvent("play_activity", true);						// show the game screen			//showGame();						// show the opening animation			showAnimation("intro_anim");		}				public function convert_meme():void{			addScore(meme_points);			converted_memes++;			var perc:Number = Math.round((converted_memes/total_memes)*100);			conversion_rate = perc;		}				public function set conversion_rate($conversion_rate):void{			_conversion_rate = $conversion_rate;			hudScreen.conversion_txt.text = String(_conversion_rate)+"%";		}				public function get conversion_rate():Number{			return _conversion_rate;		}				public function set lives($lives:uint):void{			_lives = $lives;			hudScreen.lives_txt.text = String(lives);		}				public function get lives():uint{			return _lives;		}				public function addScore($score:uint):void{			score += $score;			round_score += $score;		}				public function set score($score:uint):void{			total_score = $score;			hudScreen.score_txt.text = String(score);		}				public function get score():uint{			return total_score;		}				private function track_mouse_start(e:MouseEvent):void{			trackball.addEventListener(MouseEvent.ROLL_OUT, track_mouse_out);			//stage.addEventListener(MouseEvent.MOUSE_UP, track_mouse_up);		}				private function track_mouse_out(e:MouseEvent):void{			track_mouse_stop(e);		}				private function track_mouse_up(e:MouseEvent):void{			track_mouse_stop(e);		}				private function track_mouse_stop(e:MouseEvent):void{			// remove the listeners			trackball.removeEventListener(MouseEvent.ROLL_OUT, track_mouse_out);			//stage.removeEventListener(MouseEvent.MOUSE_UP, track_mouse_up);						// determine the direction			// based on the center of the trackball:			var direction:Number = point_direction(0, 0, e.localX, e.localY);			trace("direction: "+direction);			k_dir = angle_to_windrose(direction);			trace("k_dir: "+k_dir);			manage_kerblooey_dir();			k_angle = direction;			start_jiggle();						var rads:Number = Math.PI/180;			var vx:Number = Math.sin((k_angle+90) * rads)*3;			var vy:Number = Math.cos((k_angle+90) * rads)*3;			k_speed_x += vx;			k_speed_y += vy;						// make sure we don't exceed the max speed			k_speed_x = Math.min(k_speed_x, k_maxspeed);			k_speed_x = Math.max(k_speed_x, k_minspeed);						k_speed_y = Math.min(k_speed_y, k_maxspeed);			k_speed_y = Math.max(k_speed_y, k_minspeed);						hudScreen.trackball_mc.seam_mc.rotation = point_direction_enemy(0, 0, e.localX, e.localY);			hudScreen.trackball_mc.seam_mc.play();		}				private function point_direction(x1:Number, y1:Number, x2:Number, y2:Number):Number{			y2 *= -1;			var angle:Number = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);			return angle < 0 ? angle + 360 : angle;		}				private function point_direction_enemy(x1:Number, y1:Number, x2:Number, y2:Number):Number{			//y2 *= -1;			var angle:Number = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);			return angle < 0 ? angle + 360 : angle;		}				private function manage_kerblooey_dir(e:Event = null):void{			if(kerblooey.turn_mc)				kerblooey.turn_mc.gotoAndStop(k_dir);		}				private function start_jiggle():void{			if(jiggle_timer){				jiggle_timer.stop();			}			jiggle_timer.reset();			jiggle_timer.start();						audioManager.playSFX("rattle");		}		private function jiggle_trackball(e:TimerEvent):void{			if(jiggle_timer.currentCount/2 == Math.floor(jiggle_timer.currentCount/2)){				trackball.x = 300;				trackball.y = 387.50;			}else{				trackball.x += ((Math.random()*1)-0.5)				trackball.y += ((Math.random()*1)-0.5)			}		}				function angle_to_windrose($angle:Number):String{			var windrose:String;			if($angle < 22.5){				windrose = "E";			}else if($angle < 67.5){				windrose = "NE";			}else if($angle < 112.5){				windrose = "N";			}else if($angle < 157.5){				windrose = "NW";			}else if($angle < 202.5){				windrose = "W";			}else if($angle < 247.5){				windrose = "SW";			}else if($angle < 292.5){				windrose = "S";			}else if($angle < 337.5){				windrose = "SE";			}else{				windrose = "E";			}			return windrose;		}				private function nextLevel(e:Event = null):void{			if(this.contains(drillScreen)){				this.removeChild(drillScreen);			}						level = level+1;						if(level == (max_levels+1)){				// show the winning animation				winGame();			}else if(level == 3){				// show the mid game animation				showAnimation("midgame_anim");			}else{				// play the next level				showGame();			}		}				private function levelInit():void{			if(gamePath && gameMap.contains(gamePath))				gameMap.removeChild(gamePath);						switch(level){				case 1:					gamePath = new game_path_1();					break;				case 2:					gamePath = new game_path_2();					break;				case 3:					gamePath = new game_path_3();					break;				case 4:					gamePath = new game_path_4();					break;				case 5:					gamePath = new game_path_5();					break;			}						gameMap.addChild(gamePath);						hudScreen.level_progress_txt.text = "LEVEL "+String(level)+" PROGRESS";			//hudScreen.progress_mc. //reset			//hudScreen.damage_mc. //reset						gameMap.x = 300;			gameMap.y = 225;						gameGrid.x = 300;			gameGrid.y = 225;						gameGlyphs.x = 300;			gameGlyphs.y = 225;						gameBkgr.x = 300;			gameBkgr.y = 225;						var i:uint;			// look for h barriers			barrier_h_list = new Array();			for(i = 1;i<100;i++){				if(gamePath["barrier_h_"+String(i)] is MovieClip){					barrier_h_list.push(gamePath["barrier_h_"+String(i)]);				}else{					break;				}			}						// look for v barriers			barrier_v_list = new Array();			for(i = 1;i<100;i++){				if(gamePath["barrier_v_"+String(i)] is MovieClip){					barrier_v_list.push(gamePath["barrier_v_"+String(i)]);				}else{					break;				}			}						// look for powerup spawn points			powerup_spawn_list = new Array();			for(i = 1;i<100;i++){				if(gamePath["spawn_"+String(i)] is MovieClip){					powerup_spawn_list.push(gamePath["spawn_"+String(i)]);				}else{					break;				}			}						// look for progress markers			progress_marker_list = new Array();			for(i = 1;i<100;i++){				if(gamePath["pm_"+String(i)] is MovieClip){					progress_marker_list.push(gamePath["pm_"+String(i)]);				}else{					break;				}			}						current_enemies = new Array();			// look for enemy h spawn points			for(i = 1;i<100;i++){				if(gamePath["meme_spawn_h_"+String(i)] is MovieClip){					// place a new enemy at that point					generateEnemy(gamePath["meme_spawn_h_"+String(i)], "h");				}else{					break;				}			}						// look for enemy v spawn points			for(i = 1;i<100;i++){				if(gamePath["meme_spawn_v_"+String(i)] is MovieClip){					// place a new enemy at that point					generateEnemy(gamePath["meme_spawn_v_"+String(i)], "v");				}else{					break;				}			}						total_memes = current_enemies.length;			converted_memes = 0;			conversion_rate = 0;			exited = false;			round_score = 0;						// clean out the old powerups			current_powerups = new Array();						// fix the speed_modifier			restore_speed();						// TESTING			//hitPoints = 2;						respawn_kerblooey();		}				private function respawn_kerblooey(e:TimerEvent = null):void{			k_falling = false;			kerblooey.x = 0;			kerblooey.y = 0;						k_speed_x = 0;			k_speed_y = 0;			k_angle = 90;			k_dir = "N";						hudScreen.trackball_mc.seam_mc.stop();						hitPoints = maxHitPoints;			progress = 0;			powerup_duration_timer.stop();			speed_modifier = 1;			exited = false;						gameMap.addChild(kerblooey);			kerblooey.visible = false;						TweenLite.to(gameMap, 0.5, {x:300, y:225, onComplete:				function():void{					kerblooey.visible = true;					kerblooey.gotoAndPlay("Respawn");					audioManager.playSFX("respawn");					trackball.mouseChildren = trackball.mouseEnabled = true;				}			});		}				private function player_died(e:Event = null):void{			// subtract a life and see if we get to respawn			lives = lives-1;			if(lives >0){				respawn_timer.start();				trackball.mouseChildren = trackball.mouseEnabled = true;			}else{				//do game over				loseGame();			}		}				private function set hitPoints($hitPoints:Number):void{			_hitPoints = $hitPoints;			// FIX - represent the change in hp value in the HUD			//var perc:int = Math.round((hitPoints/maxHitPoints)*100);						if(_hitPoints == 0){				k_falling = true;				kerblooey.gotoAndStop("Explode");				audioManager.playSFX("exploding");				death_timer.start();				return;			}						//hudScreen.damage_mc.gotoAndStop(perc);			if(!hudScreen.damage_mc.hasEventListener(Event.ENTER_FRAME))				hudScreen.damage_mc.addEventListener(Event.ENTER_FRAME, animate_hp);		}				private function get hitPoints():Number{			return _hitPoints;		}				private function animate_hp(e:Event):void{			var perc:int = Math.round((hitPoints/maxHitPoints)*100);			if(hudScreen.damage_mc.currentFrame<perc){				hudScreen.damage_mc.nextFrame();			}else if(hudScreen.damage_mc.currentFrame>perc){				hudScreen.damage_mc.prevFrame();			}else{				hudScreen.damage_mc.removeEventListener(Event.ENTER_FRAME, animate_hp);			}		}				private function animate_progress(e:Event):void{			if(hudScreen.progress_mc.currentFrame<_progress){				hudScreen.progress_mc.nextFrame();			}else if(hudScreen.progress_mc.currentFrame>_progress){				hudScreen.progress_mc.prevFrame();			}else{				hudScreen.progress_mc.removeEventListener(Event.ENTER_FRAME, animate_progress);			}		}				private function hit_progress_marker($pm:MovieClip):void{			var p_n:Number = Number($pm.name.substr(3));			var perc:Number = Math.round((p_n/progress_marker_list.length)*100);			progress = perc;		}				private function set progress($progress:Number):void{			_progress = $progress;			// FIX - represent the change in hp value in the HUD			if(!hudScreen.progress_mc.hasEventListener(Event.ENTER_FRAME))				hudScreen.progress_mc.addEventListener(Event.ENTER_FRAME, animate_progress);		}				private function get progress():Number{			return _progress;		}				private function showGame():void{			levelInit();			//var shortcut:Class = bulkLoader.getContent("gameplay").applicationDomain.getDefinition("shortcut_btn");			/*shortcut_clip = new shortcut_btn();			shortcut_clip.buttonMode = true;			shortcut_clip.x = stage.stageWidth/2;			shortcut_clip.y = stage.stageHeight/2;			addChild(shortcut_clip);			shortcut_clip.addEventListener(MouseEvent.CLICK, shortcutClick);*/						// show the map for that level									addChild(gameScreen);			backgroundSWF.visible = false;						stage.addEventListener(Event.ENTER_FRAME, move_kerblooey);						powerup_spawn_timer.start();			spawn_powerup();						audioManager.playMusic("game_music", 0.5);		}				private function move_kerblooey(e:Event):void{			// save old position in case of barrier			var old_p:Point = new Point(kerblooey.x, kerblooey.y);			if(!kerblooey.parent)				return;			//if(kerblooey.currentFrame != 1){			if(!kerblooey.turn_mc){				return;			}			if(exited)				return;						// make adjustments to the speeds for the sake of powerups			var mod_speed_x:Number = (k_speed_x*speed_modifier);			var mod_speed_y:Number = (k_speed_y*speed_modifier);						kerblooey.x += mod_speed_x;			kerblooey.y += mod_speed_y;						gameMap.x -= mod_speed_x;			gameMap.y -= mod_speed_y;						gameGrid.x -= (mod_speed_x*0.5);			gameGrid.y -= (mod_speed_y*0.5);						gameGlyphs.x -= (mod_speed_x*0.3);			gameGlyphs.y -= (mod_speed_y*0.3);						keep_stuff_on_screen();						mod_speed_x *= k_decay;			mod_speed_y *= k_decay;									var kp:Point = new Point(kerblooey.x, kerblooey.y);			kp = kerblooey.parent.localToGlobal(kp);						var i:uint;			// check for colliding with barriers			for(i=0;i<barrier_h_list.length;i++){				if(barrier_h_list[i].hitTestPoint(kp.x, kp.y, true)){					// hit a barrier					// restore old position					kerblooey.y = old_p.y-mod_speed_y;					// remove all y momentum					//k_speed_y = 0;					// slightly invert momentum					k_speed_y = (k_speed_y/4)*(0-1);					break;				}			}						// check for crossing progress markers			for(i=0;i<progress_marker_list.length;i++){				if(progress_marker_list[i].hitTestPoint(kp.x, kp.y, true)){					hit_progress_marker(progress_marker_list[i]);					break;				}			}						for(i=0;i<barrier_v_list.length;i++){				if(barrier_v_list[i].hitTestPoint(kp.x, kp.y, true)){					// hit a barrier					// restore old position					kerblooey.x = old_p.x-mod_speed_x;					// remove all y momentum					//k_speed_x = 0;					// slightly invert momentum					k_speed_x = (k_speed_x/4)*(0-1);					break;				}			}						// since position may have changed due to barrier, we reset this var now			kp = new Point(kerblooey.x, kerblooey.y);			kp = kerblooey.parent.localToGlobal(kp);						// check for other collisions			// check for falling off the map			if(!gamePath.hitTestPoint(kp.x, kp.y, true)){				k_falling = true;				kerblooey.gotoAndPlay("Falling");				audioManager.playSFX("falling");				gameMap.addChildAt(kerblooey, (gameMap.getChildIndex(gamePath)));				death_timer.start();				return;			}						// check for reaching the end			if(gamePath.end_mc.hitTestPoint(kp.x, kp.y, true)){				winLevel();				return;			}						// check for colliding with powerups			for(i=0;i<current_powerups.length;i++){				if(current_powerups[i].hitTestPoint(kp.x, kp.y, true)){					gameMap.removeChild(current_powerups[i]);					collect_powerup(current_powerups[i]);					current_powerups.splice(i, 1);					break;				}			}						move_enemies();			sort_stacking();		}				private function move_enemies():void{			// move each enemy			var enemy:MovieClip;			var old_p:Point;			var new_p:Point;			var p:Point;			var direction:Number;			var angle:Number;			var wr:String;			var reverse:Boolean;			var x_dist:Number;			var y_dist:Number;			var distance:Number;			var rads:Number;			var vx:Number;			var vy:Number;			var magnet_p:Point;			var magnet_distance:Number;			if(kerblooey.turn_mc){				magnet_p = new Point(kerblooey.turn_mc.magnet_mc.x, kerblooey.turn_mc.magnet_mc.y);				magnet_p = kerblooey.turn_mc.magnet_mc.parent.localToGlobal(magnet_p);				magnet_p = gameMap.globalToLocal(magnet_p);			}			for(var i:uint = 0;i<current_enemies.length;i++){				reverse = false;				enemy = current_enemies[i];								// if the enemy is exploding then don't manage it				if(enemy.currentFrame != 1 || !gameMap.contains(enemy)){					continue;				}								old_p = new Point(enemy.x, enemy.y);				//old_p = localToGlobal(old_p);				enemy.x += enemy.speed_x;				enemy.y += enemy.speed_y;								p = new Point(enemy.x, enemy.y);				p = gameMap.localToGlobal(p);								// first priority - check for falling off map and if so reverse direction				if(!gamePath.hitTestPoint(p.x, p.y, true)){					reverse = true;					trace("falling");				}				// second priority - check for barrier collision and if so reverse direction								var j:uint;				// check for colliding with barriers				for(j=0;j<barrier_h_list.length;j++){					if(barrier_h_list[j].hitTestPoint(p.x, p.y, true)){						reverse = true;						trace("barrier h");						break;					}				}								for(j=0;j<barrier_v_list.length;j++){					if(barrier_v_list[j].hitTestPoint(p.x, p.y, true)){						reverse = true;						trace("barrier v");						break;					}				}								if(reverse){					enemy.speed_x = 0-enemy.speed_x;					enemy.speed_y = 0-enemy.speed_y;					enemy.x += (enemy.speed_x*2);					enemy.y += (enemy.speed_y*2);				}								// third priority - check for proximity to kerblooey and if close adjust direction to chase				x_dist = enemy.x-kerblooey.x;				y_dist = enemy.y-kerblooey.y;				distance = Math.sqrt(x_dist*x_dist+y_dist*y_dist);				//trace("distance: "+distance);				if(distance < stop_distance){					enemy.speed_x = 0;					enemy.speed_y = 0;					hitPoints -= meme_damage;					if(kerblooey.currentFrame == 1){						kerblooey.gotoAndPlay("Damage");						audioManager.playSFX("damage");					}				}else if(distance < chase_distance){					// start chasing					direction = point_direction_enemy(enemy.x, kerblooey.y, kerblooey.x, enemy.y);					/*trace("direction: "+direction);					k_dir = angle_to_windrose(direction);					trace("k_dir: "+k_dir);*/					angle = direction;										rads = Math.PI/180;					vx = Math.sin((angle+90) * rads);					vy = Math.cos((angle+90) * rads);					enemy.speed_x += vx;					enemy.speed_y += vy;										// make sure we don't exceed the max speed					enemy.speed_x = Math.min(enemy.speed_x, enemy_speed);					enemy.speed_x = Math.max(enemy.speed_x, (0-enemy_speed));										enemy.speed_y = Math.min(enemy.speed_y, enemy_speed);					enemy.speed_y = Math.max(enemy.speed_y, (0-enemy_speed));				}												// fourth priority - if close enough to magnet then die				if(magnet_p){					x_dist = enemy.x-magnet_p.x;					y_dist = enemy.y-magnet_p.y;					distance = Math.sqrt(x_dist*x_dist+y_dist*y_dist);					trace("distance: "+distance);					if(distance < convert_distance){						enemy.gotoAndStop("Convert");						convert_meme();						audioManager.playSFX("convert");						continue;					}				}				// fifth priority - if too close to kerblooey then stop moving and deal damage				/*				// get the current point for angle comparison				new_p = new Point(enemy.x, enemy.y);				//new_p = localToGlobal(new_p);				// update clip with the appropriate direction				//direction = point_direction_enemy(new_p.x, new_p.y, old_p.x, old_p.y);				direction = point_direction_enemy(old_p.x, old_p.y, new_p.x, new_p.y);								wr = angle_to_windrose(direction);				enemy.turn_mc.gotoAndStop(wr);				trace("old_p.x: "+old_p.x+", old_p.y: "+old_p.y);				trace("new_p.x: "+new_p.x+", new_p.y: "+new_p.y);				trace("p.x: "+p.x+", p.y: "+p.y);				trace("direction: "+direction);				trace("wr: "+wr);*/				wr = "";				if(enemy.speed_y>0){					wr = "S";				}else if(enemy.speed_y<0){					wr = "N";				}								if(enemy.speed_x>0){					wr = wr.concat("E");				}else if(enemy.speed_x<0){					wr = wr.concat("W");				}				if(wr != ""){					enemy.turn_mc.gotoAndStop(wr);				}							}		}				private function keep_stuff_on_screen():void{						// keep the grid on the screen			var grid_x:Number = gameGrid.x-300;			var grid_y:Number = gameGrid.x-225;			var grid_x_limit:Number = gameGrid.width/5;			var grid_y_limit:Number = gameGrid.height/5;						/*trace(".");			trace("grid_x: "+grid_x);			trace("grid_x_limit: "+grid_x_limit);			trace("grid_y: "+grid_y);			trace("grid_y_limit: "+grid_y_limit);			trace(".");*/						if(grid_x>grid_x_limit){				gameGrid.x -= grid_x_limit;			}						if(grid_x<(0-grid_x_limit)){				gameGrid.x += grid_x_limit;			}						if(grid_y>grid_y_limit){				gameGrid.y -= grid_y_limit;			}						if(grid_y<(0-grid_y_limit)){				gameGrid.y += grid_y_limit;			}						// keep the glyphs on the screen			var glyph_x:Number = gameGlyphs.x-300;			var glyph_y:Number = gameGlyphs.x-225;			var glyph_x_limit:Number = gameGlyphs.width/5;			var glyph_y_limit:Number = gameGlyphs.height/5;						if(glyph_x>glyph_x_limit){				gameGlyphs.x -= glyph_x_limit;			}						if(glyph_x<(0-glyph_x_limit)){				gameGlyphs.x += glyph_x_limit;			}						if(glyph_y>glyph_y_limit){				gameGlyphs.y -= glyph_y_limit;			}						if(glyph_y<(0-glyph_y_limit)){				gameGlyphs.y += glyph_y_limit;			}		}				private function shortcutClick(e:MouseEvent):void{			removeChild(shortcut_clip);			startDrill();		}				private function startDrill():void{			conversion_bonus = Math.floor(Number(round_score*(conversion_rate/100)));			(drillScreen.title_txt as TextField).text = "Cyber Saf-e-Drill"+String(level);			(drillScreen.question_txt as TextField).text = drillQuestions[level-1]['text'];			(drillScreen.bonus_txt as TextField).text = String(conversion_rate)+"% = "+String(conversion_bonus)+" pts.";			addChild(drillScreen);			drillScreen.mouseEnabled = drillScreen.mouseChildren = true;			drillScreen.squares_mc.gotoAndStop(level+1);						my_hitbox.logGameEvent("drill", false);			audioManager.playMusic("menu_music");		}				private function shuffle_array($arr:Array):Array{			var len:int = $arr.length;			var arr1:Array = new Array().concat($arr);			var arr2:Array = new Array(len);			for(var i:int = 0; i<len; i++)			{				arr2[i] = arr1.splice(int(Math.random() * (len - i)), 1)[0];			}			return arr2;		}				private function menuInit():void{			splashScreen = new splash_screen();			splashScreen.play_btn.addEventListener(MouseEvent.CLICK, play_click);			splashScreen.instructions_btn.addEventListener(MouseEvent.CLICK, menu_instructions_click);			splashScreen.highscores_btn.addEventListener(MouseEvent.CLICK, menu_highscores_click);		}				private function menu_instructions_click(e:MouseEvent):void{			audioManager.playSFX("click");			removeChild(splashScreen);			showInstructions();		}				private function menu_highscores_click(e:MouseEvent):void{			audioManager.playSFX("click");			removeChild(splashScreen);			showHighScores();		}				private function showMenu():void{			//splashScreen.play_btn.visible = false;			//splashScreen.instructions_btn.visible = false;			//splashScreen.highscores_btn.visible = false;			addChild(splashScreen);			audioManager.playMusic("menu_music", 0.5);						TweenLite.from(splashScreen.play_btn, 0.3, {x:splashScreen.play_btn.x+400});			TweenLite.from(splashScreen.instructions_btn, 0.3, {x:splashScreen.instructions_btn.x+400, delay:0.2});			TweenLite.from(splashScreen.highscores_btn, 0.3, {x:splashScreen.highscores_btn.x+400, delay:0.4});		}				private function instructionsInit():void{			instructionsScreen = new instructions_screen();			instructionsScreen.play_btn.addEventListener(MouseEvent.CLICK, play_click);			instructionsScreen.next_btn.addEventListener(MouseEvent.CLICK, instructions_next_click);			instructionsScreen.prev_btn.addEventListener(MouseEvent.CLICK, instructions_prev_click);		}				private function instructions_next_click(e:MouseEvent):void{			var text_mc:MovieClip = (instructionsScreen.text_mc as MovieClip);			TweenLite.to(text_mc, 0.2, {x:-600, onComplete:				function():void{					text_mc.nextFrame();					text_mc.x = 600;					TweenLite.to(text_mc, 0.2, {x:0});					checkInstructions();				}			});			audioManager.playSFX("swoosh");		}				private function instructions_prev_click(e:MouseEvent):void{			var text_mc:MovieClip = (instructionsScreen.text_mc as MovieClip);			TweenLite.to(text_mc, 0.2, {x:600, onComplete:				function():void{					text_mc.prevFrame();					text_mc.x = -600;					TweenLite.to(text_mc, 0.2, {x:0});					checkInstructions();				}			});			audioManager.playSFX("swoosh");		}				private function showInstructions():void{			(instructionsScreen.text_mc as MovieClip).gotoAndStop(1);			checkInstructions();			addChild(instructionsScreen);			my_hitbox.logGameEvent("instructions", false);		}				private function checkInstructions():void{			var text_mc:MovieClip = (instructionsScreen.text_mc as MovieClip);						// check for previous button			if(text_mc.currentFrame == 1){				instructionsScreen.prev_btn.visible = false;			}else{				instructionsScreen.prev_btn.visible = true;			}						// check for next button			if(text_mc.currentFrame == text_mc.totalFrames){				instructionsScreen.next_btn.visible = false;			}else{				instructionsScreen.next_btn.visible = true;			}		}				private function highScoresInit():void{			highScoresScreen = new highscores_screen();			highScoresScreen.play_btn.addEventListener(MouseEvent.CLICK, play_click);		}				private function showHighScores():void{			// refresh the data each time we view the high scores			populateHighScores();						// show the screen			addChild(highScoresScreen);			my_hitbox.logGameEvent("high_scores", false);		}				private function populateHighScores():void{			var scores_mc:MovieClip = (highScoresScreen.scores_mc as MovieClip);						// hide the high scores until we have received data			scores_mc.visible = false;						// PLACEHOLDER run this function when we actually get the high scores			var boardLoader:URLLoader = new URLLoader();			boardLoader.addEventListener(Event.COMPLETE, populateHighScores_loaded);			//boardLoader.addEventListener(IOErrorEvent.IO_ERROR, onError);			boardLoader.load(new URLRequest("../scores/getGameHighScores.asp?gameid=496"));						//populateHighScores_loaded();		}				// this is the function for when we have successfully loaded the high scores and will probably need an event  		private function populateHighScores_loaded(e:Event):void{			// PLACEHOLDER create some dummy values <			/*var hsData:Array = [				 {inits:'ABC', score:9876543}				,{inits:'ABD', score:9876542}				,{inits:'ABE', score:9876541}				,{inits:'ABF', score:9876540}				,{inits:'ABG', score:9876539}				,{inits:'ABH', score:9876538}				,{inits:'ABI', score:9876537}				,{inits:'ABJ', score:9876536}				,{inits:'ABK', score:9876535}				,{inits:'ABL', score:9876534}			];*/			// >			var dataObject:Object = new Object();			var dataArray:Array = String(e.target.data).split("&");			var dataChunk:String;			var _type:String;			var typeValue:String;			for (var i:int=0; i<dataArray.length; i++) {				dataChunk = dataArray[i];				_type = dataChunk.substr(0, dataChunk.indexOf("=",0));				typeValue = dataChunk.substr(dataChunk.indexOf("=",0)+1, dataChunk.length);				dataObject[_type] = typeValue;			}			//var _alert:alert= new alert;			var scores_mc:MovieClip = (highScoresScreen.scores_mc as MovieClip);			var score_item:MovieClip;			for (var j:int=0; j<10; j++){				score_item = scores_mc['hs_'+String(Number(j+1))];				score_item['num_txt'].text = String(Number(j+1));				//_alert.fire ("here "+ dataObject["name"+(j)])				if (dataObject["name"+(j)]!=undefined) {										score_item['inits_txt'].text = dataObject["name"+(j)].toUpperCase();					score_item['score_txt'].text = dataObject["score"+(j)];					//this["nameTxt"+(j)].text=dataObject["name"+(j)].toUpperCase();					//this["scoreTxt"+(j)].text=dataObject["score"+(j)];				} else {					score_item['inits_txt'].text = "AAA";					score_item['score_txt'].text = "0"					//this["nameTxt"+(j)].text="AAA";					//this["scoreTxt"+(j)].text="0";				}			}			// put the high score values into the clips			/*var scores_mc:MovieClip = (highScoresScreen.scores_mc as MovieClip);			var score_item:MovieClip;			for(var i:uint = 0;i<hsData.length;i++){				score_item = scores_mc['hs_'+String(Number(i+1))];				score_item['num_txt'].text = String(Number(i+1));				score_item['inits_txt'].text = hsData[i]['inits'];				score_item['score_txt'].text = hsData[i]['score'];			}*/						// show the scores			scores_mc.x = 600;			scores_mc.visible = true;			TweenLite.to(scores_mc, 0.2, {x:0});			audioManager.playSFX("swoosh");		}				private function play_click(e:MouseEvent):void{			if(this.contains(splashScreen))				removeChild(splashScreen);						if(this.contains(instructionsScreen))				removeChild(instructionsScreen);						if(this.contains(highScoresScreen))				removeChild(highScoresScreen);						audioManager.playSFX("click");			newGame();		}				private function loseGame():void{			// always coming from game mode, since lose is caused by 0 lives			endLevel();			// show game over animation			showGameOver("gameover_anim");		}				private function winGame():void{			// always coming from drill mode, since win is caused by completing all 5 levels followed by 5 drills			// drill interface removed by nextLevel()			// stop the game music			audioManager.stopMusic();			// show game over animation			showGameOver("endgame_anim");		}				private function exitLevel(e:Event):void{			endLevel();			// show the drill			startDrill();		}				private function endLevel():void{			// stop the game music			audioManager.stopMusic();			// stop game listeners						// stop any timers			jiggle_timer.stop();			respawn_timer.stop();			death_timer.stop();			powerup_spawn_timer.stop();			powerup_duration_timer.stop();						// remove any leftover enemies or powerups			var i:uint;			for(i=0;i<current_enemies.length;i++){				gameMap.removeChild(current_enemies[i]);			}			for(i=0;i<current_powerups.length;i++){				gameMap.removeChild(current_powerups[i]);			}						// remove game interface						removeChild(gameScreen);			backgroundSWF.visible = true;			stage.removeEventListener(Event.ENTER_FRAME, move_kerblooey);			powerup_spawn_timer.stop();						// send a hitbox event			my_hitbox.logGameEvent("beat_level "+String(level), false);		}				private function winLevel():void{			exited = true;			kerblooey.gotoAndPlay("Exit");			audioManager.playSFX("exit");		}				private function animationInit():void{			animationScreen = new animation_screen();			animationScreen.skip_btn.addEventListener(MouseEvent.CLICK, skip_click);		}				private function skip_click(e:MouseEvent):void{			my_hitbox.logGameEvent("skip_animation", false);			animation.stop();			SoundMixer.stopAll();			this.removeChild(animation);			this.removeChild(animationScreen);			showGame();		}				private function gameOverInit():void{			gameOverScreen = new game_over_screen();			// show submit field and button			gameOverScreen.submit_btn.addEventListener(MouseEvent.CLICK, submit_click);						gameOverScreen.inits_txt.addEventListener(Event.CHANGE, inits_change);			gameOverScreen.inits_txt.addEventListener(MouseEvent.CLICK, inits_click);		}				private function inits_click(e:MouseEvent):void{			(gameOverScreen.inits_txt as TextField).setSelection(0, gameOverScreen.inits_txt.length);		}				private function inits_change(e:Event):void{			gameOverScreen.inits_txt.text = gameOverScreen.inits_txt.text.toUpperCase();		}				private function showAnimation($name:String):void{			if(this.contains(gameScreen))				this.removeChild(gameScreen);						animation = bulkLoader.getContent($name);			animation.y = 50;						backgroundSWF.visible = true;			this.addChild(animation);			this.addChild(animationScreen);						animation.gotoAndPlay(2);						audioManager.stopMusic();		}				private function showGameOver($name:String):void{			if(this.contains(gameScreen))				this.removeChild(gameScreen);						// show the correct results and rank			var correct_results:uint = 0;						var i:uint;			// reset all result icons			for(i = 1;i<=5;i++){				gameOverScreen['result_'+String(i)].gotoAndStop(1);			}						// configure the icons for which we have recorded results			for(i = 0;i<drillResults.length;i++){				if(drillResults[i]){					gameOverScreen['result_'+String(Number(i+1))].gotoAndStop(2);					correct_results++;				}else{					gameOverScreen['result_'+String(Number(i+1))].gotoAndStop(3);				}			}			gameOverScreen.squares_mc.gotoAndStop(drillResults.length+1);			gameOverScreen.rank_txt.text = "RANK: "+String(rank_names[correct_results]);			gameOverScreen.score_txt.text = String(total_score);						// show the correct message			if($name == "gameover_anim"){				gameOverScreen.message_mc.gotoAndStop(1);			}else if($name == "endgame_anim"){				gameOverScreen.message_mc.gotoAndStop(2);			}						// fetch the animation from the loader			animation = bulkLoader.getContent($name);			animation.y = 50;						backgroundSWF.visible = true;			this.addChild(animation);			this.addChild(gameOverScreen);						animation.gotoAndPlay(2);						audioManager.stopMusic();		}				private function submit_click(e:MouseEvent):void{			var deets:Object = {'inits':gameOverScreen.inits_txt.text, 'score':total_score};			var submitLoader:URLLoader = new URLLoader();			submitLoader.addEventListener(Event.COMPLETE, submit_success);			submitLoader.load(new URLRequest("../scores/writeGameHighScore.asp?gameid=496&name="+(deets.inits)+"&score="+deets.score));						// PLACEHOLDER need info to send score			//			// PLACEHOLDER the result of posting score should be a visit to high scores			//submit_success();		}				private function submit_success(e:Event):void{ // will need event						// remove remnants of the animation						if(this.contains(animation))				this.removeChild(animation);			if(this.contains(animationScreen))				this.removeChild(animationScreen);			if(this.contains(gameOverScreen))				this.removeChild(gameOverScreen);						animation.stop();			SoundMixer.stopAll();						showHighScores();		}				private function spawn_powerup(e:TimerEvent = null):void{			// no more places to put powerups			if(powerup_spawn_list.length == 0){				powerup_spawn_timer.stop(); // no need to keep firing events if we're out of spots				return;			}						// randomly determine which powerup to place			var powerup_type:String = powerup_types[Math.floor(Math.random()*powerup_types.length)];						var powerup_clip:MovieClip;			switch(powerup_type){				case "turbo":					powerup_clip = new pickup_turbo();					break;								case "gum":					powerup_clip = new pickup_gum();					break;								case "fix":					powerup_clip = new pickup_wrench();					break;			}						// add clip to the list we use to track hits on powerups			current_powerups.push(powerup_clip);						// randomly pick one of the spawn points			var index:uint = Math.floor(Math.random()*powerup_spawn_list.length);			var spawn_point:MovieClip = powerup_spawn_list[index];			// remove that spawn point from the list			powerup_spawn_list.splice(index, 1);						// add clip to the stage			powerup_clip.x = spawn_point.x;			powerup_clip.y = spawn_point.y;						gameMap.addChildAt(powerup_clip, gameMap.getChildIndex(kerblooey));		}				private function collect_powerup($powerup_clip:MovieClip):void{			// check for type			var type:String;			if($powerup_clip is pickup_turbo){				type = "turbo";			}else if($powerup_clip is pickup_gum){				type = "gum";			}else if($powerup_clip is pickup_wrench){				type = "fix";			}						// play sound			audioManager.playSFX(type);						// trigger effect			switch(type){				case "turbo":					speed_modifier = 1.5;					break;								case "gum":					speed_modifier = 0.5;					break;								case "fix":					hitPoints = maxHitPoints;					break;			}						// start the timer			powerup_duration_timer.reset();			powerup_duration_timer.start();		}				private function restore_speed(e:TimerEvent = null):void{			speed_modifier = 1;		}				private function generateEnemy($clip:MovieClip, $plane:String):void{			var enemy:MovieClip = new meme_clip();			enemy.gotoAndStop("Default");			// give them some speed			switch($plane){				case "h":					if(Math.random() > 0.5){						enemy.speed_x = enemy_speed;					}else{						enemy.speed_x = (0-enemy_speed);					}					enemy.speed_y = 0;					break;								case "v":					if(Math.random() > 0.5){						enemy.speed_y = enemy_speed;					}else{						enemy.speed_y = (0-enemy_speed);					}					enemy.speed_x = 0;					break;			}			//enemy.speed_x = 0;			//enemy.speed_y = 0;							current_enemies.push(enemy);			var p:Point = new Point($clip.x, $clip.y);			//p = localToGlobal(p);			//p = gameMap.globalToLocal(p);			enemy.x = p.x;			enemy.y = p.y;			enemy.scaleX = enemy.scaleY = piece_scale;			gameMap.addChild(enemy);		}				private function sort_stacking():void{			var stack_list:Array = [kerblooey];			stack_list = stack_list.concat(current_enemies);			stack_list = stack_list.concat(current_powerups);			stack_list.sortOn("y");			stack_list.reverse();						// re-add all gameMap objects according to y stack			for(var i:uint = 0;i<stack_list.length;i++){				gameMap.addChild(stack_list[i]);			}		}	}}